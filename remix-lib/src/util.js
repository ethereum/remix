'use strict'
module.exports = {

  /**
    * return a regex which extract the swarmhash from the bytecode.
    *
    * @return {RegEx}
    */
  swarmHashExtraction: function () {
    return /a165627a7a72305820([0-9a-f]{64})0029$/
  },

  /**
    * return a regex which extract the swarmhash from the bytecode, from POC 0.3
    *
    * @return {RegEx}
    */
  swarmHashExtractionPOC31: function () {
    return /a265627a7a72315820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/
  },

  /**
    * return a regex which extract the swarmhash from the bytecode, from POC 0.3
    *
    * @return {RegEx}
    */
  swarmHashExtractionPOC32: function () {
    return /a265627a7a72305820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/
  },

  /**
    * return a regex which extract the cbor encoded metadata : {"ipfs": <IPFS hash>, "solc": <compiler version>} from the bytecode.
    * ref https://solidity.readthedocs.io/en/v0.6.6/metadata.html?highlight=ipfs#encoding-of-the-metadata-hash-in-the-bytecode
    * @return {RegEx}
    */
  cborEncodedValueExtraction: function () {
    return /64697066735822([0-9a-f]{68})64736f6c6343([0-9a-f]{6})0033$/
  },

  extractcborMetadata: function (value) {
    return value.replace(this.cborEncodedValueExtraction(), '')
  },

  extractSwarmHash: function (value) {
    value = value.replace(this.swarmHashExtraction(), '')
    value = value.replace(this.swarmHashExtractionPOC31(), '')
    value = value.replace(this.swarmHashExtractionPOC32(), '')
    return value
  },

  /**
    * Compare bytecode. return true if the code is equal (handle swarm hash and library references)
    * @param {String} code1 - the bytecode that is actually deployed (contains resolved library reference and a potentially different swarmhash)
    * @param {String} code2 - the bytecode generated by the compiler (contains unresolved library reference and a potentially different swarmhash)
                              this will return false if the generated bytecode is empty (asbtract contract cannot be deployed)
    *
    * @return {bool}
    */
  compareByteCode: function (code1, code2) {
    if (code1 === code2) return true
    if (code2 === '0x') return false // abstract contract. see comment

    if (code2.substr(2, 46) === '7300000000000000000000000000000000000000003014') {
      // testing the following signature: PUSH20 00..00 ADDRESS EQ
      // in the context of a library, that slot contains the address of the library (pushed by the compiler to avoid calling library other than with a DELEGATECALL)
      // if code2 is not a library, well we still suppose that the comparison remain relevant even if we remove some information from `code1`
      code1 = replaceLibReference(code1, 4)
    }
    let pos = -1
    while ((pos = code2.search(/__(.*)__/)) !== -1) {
      code2 = replaceLibReference(code2, pos)
      code1 = replaceLibReference(code1, pos)
    }
    code1 = this.extractSwarmHash(code1)
    code1 = this.extractcborMetadata(code1)
    code2 = this.extractSwarmHash(code2)
    code2 = this.extractcborMetadata(code2)

    if (code1 && code2 && code1.indexOf(code2) === 0) {
      return true
    }
    return false
  }
}

function replaceLibReference (code, pos) {
  return code.substring(0, pos) + '0000000000000000000000000000000000000000' + code.substring(pos + 40)
}
